1. What is a Configuration?

The purpose of the configuration is to create an application solution for an application in which there are various business processes with a set of screens, some visual elements and logic. The application interprets the configuration and executes handlers

A configuration is a JSON file that tells the app:

a) What screens to show?
b) What UI-elements (buttons,fields or other) to display?
c) What happens when you click buttons or other elements?

Basic structure of configuration:

json
{
  "ClientConfiguration": {
    "ConfigurationName": "My App",
    "Processes": [],
    "Layouts":[],
    "CommonHandlers": [],
    "Mediafile": []
	
  }
}

2. Creating a Process
A process is a set of screens(Operations):

json
{
  "type": "Process",
  "ProcessName": "My Process",
  "Operations": [
 
]
}

3. Adding Screens
Each screen has:

a) Elements (buttons, text fields)
b) Handlers (what happens when you click)

json
{
  "type": "Operation",
  "Name": "Screen1",
  "Elements": [
/* Put root LinearLayout and Other operation elements here. */
],
  "Handlers": [],
  "noScroll": true,
  "hideBottomBarScreen": true
}

Switching between screens is done using the command-variable ShowScreen (see below)

In Operation, by default option noScroll is false. This means that all screen elements are placed with infinite scrolling vertically. But with infinite scrolling you can not place elements that need to be stretched to the full height. Therefore, if the screen uses elements that need to be stretched in height or uses HTML or ActiveCV, then you must use option "noScroll": true. Also, for compatibility reasons, you must use option "hideBottomBarScreen": true
In Elements you can place the root LinearLayout (which contains UI elements from the UI Elements section) and Other Operation Elements such as Barcode, Photo, etc. (from the Other Operation Elements section)
There must always be a root LinearLayout and root layout should have a vertical orientation. Visual UI elements (list in UI Elements section, see point 5) except non-UI elements(list on Other Operation elements) can't just be in Operation. Elements, they must be in some root LinearLayout!

4. Layout (containers of UI-elements) 

Put elements in containers(layouts) to arrange them:

json
{
  "type": "LinearLayout",
  "orientation": "vertical",
  "Elements": [
    /* Put UI-elements here */
  ]
}


LinearLayout(container) must have an orientation - vertical or horizontal



All elements (both layouts and UI elements) have height and width.

height and width can take the values: "match_parent" - full width, "wrap_content" - by element size, numeric value. "weight" - numeric value, default - 1. If you need to distribute several elements within a container proportionally to width or length, then you need to do the following (an example for horizontal distribution, a similar rule applies to vertical distribution): 1) variables must be included in a horizontal container (type: LinearLayout, orientation: horizontal), with a width of match_parent 2) elements inside must have a width = 0 3) elements must have a weight in the proportions in which you need to distribute the elements on the screen. For example, if two elements should divide the width in half, then both should have a weight of 1, if one should be twice as wide, then it should have a weight of 2, and the other - 1.

Another common layout option: you need to stretch an element, but leave space for elements above and below. For example, you have several elements above, and you want to place a block of buttons below. The space between them can be empty, or occupied by a list, as an option. To do this, the elements above have a height according to the size of the elements (wrap_content), below - also according to the size of the elements, and the element in the middle has height = 0 and weight) = 1

For the purposes of designing lists(Card) and dialogs(ShowDialogLayout), layouts can be placed in the Layouts section of the configuration. To do this, they must have a Variable

json
[{
"type": "Button",
"Value": "Click 1",
"Variable": "my_button_1"
},
{
"type": "Button",
"Value": "Click 2",
"Variable": "my_button_2"
}]

When you click the Click 2 button, there will be an onInput event with listener=my_button_2

This way you can separate events from different elements.
But there is an exception. The list is generated by listener=CardsClick

5. UI Elements

In order to add a title to the input field (EditTextText,EditTextPass etc), you can organize a horizontal (or vertical) container in which you need to place the TextView and the input field.The same goes for the TextView header and other elements. It needs to be done using another TextView.

1) Text Display:

Example:

json
{
  "type": "TextView",
  "Value": "Hello World",
  "height": "wrap_content",
  "width": "match_parent"

		
}

2) Number Input:

json
{
  "type": "EditTextNumeric",
  "Variable": "number1",
  "Value" : @number1	
}

3) Text input

json
{
  "type": "EditTextText",
  "Variable": "text1",
  "Value": "@text1"
}


4) Button:

json
{
  "type": "Button",
  "Value": "Click Me",
  "Variable": "my_button"
}

5) MultilineText – multiline text. The selected value is placed in Variable. @<element variable> can be placed in Value to fill in by default when the screen is refreshed.

json
{
  "type": "MultilineText",
  "Variable": "text1",
  "Value": "@text1"
}

6) EditTextPass – password input field

json
{
  "type": "EditTextPass",
  "Variable": "password",
  "Value": "@password"
}

7) SpinnerLayout - drop-down list. The list value can be set as a string with a separator ";" via a variable or directly in the constructor. The first element in the list will always be selected, so if you want it to be empty by default, the first element should be an empty string or something similar. For example, "<Select a value>;First;Second". The selected value is returned to the Variable. You can specify a default value - the value that will be selected when opening. To do this, you need to put a variable with the name of the result variable on the variable stack. For example, if the variable is res, then put it in hashMap.put("res","Second").

json
{
"type": "SpinnerLayout",
"Variable": "selected_value",
"Value": "@my_lisy"
}

8) CheckBox – a checkbox for boolean values. Value – a header, the value selected from the variable stack is stored in Variable. Let's say Variable=done. Then, in order to initiate the checkbox in "true", you need to put hashMap.put("done","true") in the stack. If the user unchecks/checks the box, an event is generated with a listener equal to the element variable, and the string "true" or "false" is placed in hashMap

json
{
"type": "SpinnerLayout",
"Variable": "done",
"Value": "Work done"
}

9) DateField - date selection field. When selecting a date, the date selected by the user, formatted according to the regional settings, is written to the date variable, and the date in ISO format is written to the <field_variable>_d variable. 

json
{
  "type": "DateField",
  "Variable": "@date",
  "Value": "date"
}

10)CardsLayout – list of cards (list). The Value must contain a variable that defines the list settings. When a list item is selected, a CadsClick event occurs

json
{
"type": "CardsLayout",
"Value": "@cards"
}

The variable that is specified in Value must have the structure:

json
{ "customcards":{
"options": /*OPTIONS*/,
"layout": /* LAYOUT see below */,
"cardsdata": /* DATASET see below */
}
}

Where:

LAYOUT is a reference to a container defined in the section Layouts with the prefix "^". This means that if in "Layouts" a LinearLayout is defined with Variablе equal to, for example, card1, then "layout": "^card1" should be specified. Important! It is necessary to specify the variable name with this prefix.

DATASET is an array of JSON objects, one for each list item. In which the variables displayed in the container are listed (via @). Any other (not displayed in the interface) can also be added. You can also specify a key separately in the dataset element – ​​a key that is returned when clicked in a special variable (returned in selected_card_key)
An example of defining a list of cards in Python (without using the dataset mechanism, with search options in the toolbar and saving the position)

OPTIONS is a JSON object with possible keys:
• search_enabled, boolean – activation of search by list data
• save_position, boolean – saving the current position when refreshing the screen. For example, when refreshing a row.
• colorizing, boolean use of selective coloring of elements (using the _background property)
• horizontal, boolean – horizontal direction of the list

import json

j = { "customcards": {
"layout": "^card1",
"cardsdata":[]}
}

j["customcards"]["cardsdata"].append({"text1":"Some heading 1","text2":"Subheading №1"})
j["customcards"]["cardsdata"].append({"text1":"Some heading 2","text2":"Subheading №2"})

hashMap.put("cards",json.dumps(j,ensure_ascii=False))

In this example, card1 is the layout defined in the Layouts array of the configuration.


When clicking on a list item, a CardsClick event is generated. The following appears in the variables:

selected_card_key – the value of the key field, if the list element has a key field
selected_card_position – list position
selected_card_data (if the variable "return_selected_data" is added to hashMap in advance) – the entire record as a JSON array element

The list item container allows the use of active elements: Button, Menu and Checkbox. When clicked, they will generate an event with listener=LayoutAction separate from clicking on the card itself. The layout_listener and card_data variables are also pushed into the variable stack. The listener contains the variable of the element that generated the event (button, menu item, checkbox). The card_data contains the list item data as a JSON string. To add a menu, you need to place the PopupMenuButton element in the container, and pass a list of menu items separated by a semicolon as the value. For example, "First;Second"
When the state of the Checkbox changes, the table variable changes - in the list elements, the value of the element changes, with the checkbox variable.

Any list item can have a background (colored in the desired color) if you specify the _background key with the color as a HEX value in the list item. In this case, the colorizing:true option must be in the "options" object

There is a layout for all list items, but in any list item you can define your own special layout of the item using the _layout key (The link to the layout is specified using a prefix "^"). For example:

j = { "customcards": {
"layout": "^card1",
"cardsdata":[]}
}

j["customcards"]["cardsdata"].append({"text1":"Some heading 1","text2":"Subheading №1"})
j["customcards"]["cardsdata"].append({"_layout":"^my_special_layout","text1":"Some heading 2","text2":"Subheading №2"})
j["customcards"]["cardsdata"].append({"text1":"Some heading 3","text2":"Subheading №3"})



11) Picture - a picture where the value is specified: either as a link to an absolute path to the file via the "~" prefix (for example: "my_folder\my_picture.jpg"), or via a link to a media resource (static resource) via "^" (see below), or as a base64 string
{
"type": "Picture",
"Value": "@pic"
}

12) html - a field of an HTML document. The value is specified as an HTML string

{
"type": "html",
"Value": "@MyHTML"
}

13) Gauge - an arrow diagram (indicator) for visual representation of some value. The value is a JSON string with the keys Min (minimum scale value), Max (maximum scale value), Unit (unit of measurement), and Value (current value)

Example:

{
"type": "Gauge",
"Value": "@tasks"
}

python:

hashMap.put("tasks",json.dumps({"Min":0,"Max":100,"Value":q,"Unit":" "})) 

14) TableLayout. Another form of the list. Everything that was specified for CardsLayout is true for TableLayout except for the variable format. Instead of customcards, the custmtable key is used, instead of cardsdata, the tabledata key is used. Everything else - options, events, variables - is similar.

json
{
"type": "TableLayout",
"Value": "@cards"
}

The variable that is specified in Value must have the structure:

{ "customtable":{
"options": /*OPTIONS*/,
"layout": /* LAYOUT see below */,
"tabledata": /* DATASET see below */
}
}

15) camera camera is an element that provides a continuous CV stream and allows you to output graphics for objects in the frame. Various detectors (barcodes, OCR, etc.) are used to recognize objects. This object is called ActiveCV. See the context for it in a separate file "activecv.txt".
json:
{
"type": "camera",
"Variable": "cam"
}


6. Properties of elements and containers
1) Variable. This is the ID of the element. It performs several functions:

a) as a rule, when generating events, the variable name is written in the listener (for example, there are several buttons on the screen and when you press a button, the button variable is written in the listener)

b) You can access the element by the variable, for example, set visibility (see below)

2)Value. Depending on the type of element, this is a different value visible in the element. For a label, this is the text of the label, for a button - the button text, for a table - the entire layout of the table with data, etc. The value can be set as a constant, i.e. as simple text in the configuration, or as a link to a stack variable (via the @ symbol). This means that if you put a variable a in the hashMap with the text "Hello world", and specify @a in Value (before drawing the screen), then when the screen is refreshed, the caption will display "Hello world". Important: if a constant is used, it must be either JSON compatible or escaped. The value can be either a constant or a variable with the @ prefix. For example, you can't do "Age: @age", instead you just need to do "@age", and when placing a variable, specify hashMap.put("age","Age :"+str(age)). You can also somehow visually highlight this using HTML: hashMap.put("age","Age :<b>"+str(age)+"</b>")

3)BackgroundColor - a color specified as a HEX value. For example, #89f096

4)StrokeWidth - draws a frame around the container or element with a specified thickness in screen units

5)Padding - indents inward the container in screen units

6)Radius - if the Border Thickness is specified, then not straight fields are drawn, but a rounding. You can assign a radius of -1 to an element. Then the rounding will be in the form of a full circle.



7. Making UI-elements Work

When a button is clicked, run Python code:

json
{
  "event": "onInput",
  "action": "run",
  "listener": "my_button",
  "type": "pythonscript",
  "method": "encoded_python_code"
}


Where the event name is either "onStart" or "onInput". onStart occurs when the screen loads, onInput when interacting with visual elements.
After the onInput event, the screen is reloaded and the onStart event occurs. If you want to initialize variables on the screen (like list variable), describe this in onStart
Code needs to be written in the handler, without packing it into a function, it will be executed as excec()

encoded_python_code is the Python code that needs to be encoded into a base64 string.This means that you need to create code in Python, then translate it into base4 and place it in the handler object in the handlers array in the "method" field. The standard Python libraries and the requests library are available.

Python example (before encoding):

python
# Show message when button clicked
toast("Button was clicked!")



Variables are passed between the screen and the handler via hashMap (variables stack). hashMap has the methods put(variable_name, variable_value) - put a variable onto the stack, get(variable_name) - get a variable, containsKey(variable_name) - check if a variable exists (boolean) and remove(variable_name). All values ​​are strings. Numbers, dictionaries and other types need to be converted to strings.
Variables exist as long as the process exists.

python
#put my_text in code
hashMap.put("my_text","Hello world")

Some variables are commands:

1) ShowScreen, screen_name – switches to another screen in the process. That is, if the process has Screen1 and Screen2, then ShowScreen, Screen2 will cause Screen2 to start with the corresponding onStart, onPostStart events.

hashMap.put("ShowScreen","Screen 2");

2) ShowScreen, process_name|screen_name - a command to borrow a screen from any process (not necessarily the current one).

hashMap.put("ShowScreen","General forms|Screen 2");

3) ResreshScreen, without a parameter – refresh (redraw the screen) without calling onStart/onPostStart. It is needed to redraw elements from the filled variables. It is mandatory to use with any async.

4) RestartScreen, without parameters – restart the screen, with onStart/onPostStart execution

5) StartProcess, process_name – start the process

6) ShowProcessScreen, process_name – start the process from the background (when no process is running)

7) FinishProcess, without parameter – end the process

8) ShowDialog Call a dialog. You can place your own input elements on it. To call and customize the dialog, you will need one or more commands:

8.1) ShowDialog, <dialog text> - A mandatory command for actually starting the dialog. If you do not specify the other commands, the dialog will simply be a question (dialog title) with Yes/No buttons
9.1) ShowDialogLayout , <container JSON structure/link to container> - defines the contents of the dialog window, in case it is necessary to redefine it (add your own elements). It is used together with the ShowDialog command. It is better to specify a link to the container in the Containers section as a parameter through "^" prefix (similar to, for example, setRootLayout or a container in the list), but you can also specify just a JSON string of the container.
9.2) ShowDialogStyle,

{"title":"<title>","yes":"Yes button text","no":"No button text"} defines the names of the buttons and the title

9.3) ShowDialogListener, event_name – defines the name of the event (listener) when the dialog is triggered
9.4) ShowDialogSilent, without a parameter – the dialog does not trigger the screen redraw event (and onStart/onPostStart)
9.5) the dialog returns the event onInput and put in hashMap variable "event" with value onResultPositive (pressed OK) or onResultNegative (pressed Cancel) depending on what the user selected in the stack variable "action". That is, you need to analyze what the user selected by the variable action: if hashMap.get("action")=="onResultPositive": #do if OK pressed

Example:

hashMap.put("ShowDialog","")
hashMap.put("ShowDialogStyle",json.dumps({"title": "Adding a record", "yes": "Save", "no": "Cancel" }))
hashMap.put("ShowDialogLayout","^my_dialog")
hashMap.put("ShowDialogListener","dialog_result")

The android module is also available, which contains the following functions
Interface commands:

1) toast(String toast) – display an Android message
2) speak(String text) – speak the text by voice
3) listen() – start waiting for speech recognition
4) vibrate() and vibrate(int duration) – vibration and vibration of a specified duration
5) beep() - sound signal
6) notification(String message)/ notification (String message,String title)/ notification(String message,String title,int number) – notification in the notification curtain. Number – notification identifier, by which it can be accessed later to either remove or rewrite (update)
7) notification_progress(String message,String title,int number,int progress) – notification with a progress bar (from 0 to 100) notification_cancel(int number) – hide notification

To control the visibility of individual screen elements, use the Show_<Element ID> command, for example hashMap.put("Show_left","-1") `` , where left is the element variable (variable=identifier). Values ​​can be:

"1" - visible
"0" - not visible, without freeing up space,
"1" - visible, with freeing up space

You can use the **noRefresh** command, which disables redrawing of elements - i.e. updating the screen when executing the handler. Example:

.. code-block:: Python

hashMap.put("noRefresh","")

You can disable events for input fields that automatically generate events when entering (for example, a check mark, fields with character input tracking):
hashMap.put("disable_events","")

All labels, almost all elements (not only the Label elements themselves, but also other elements, such as text in tables) can be marked with HTML tags. This is a powerful and simple way to liven up the interface without complicating it with unnecessary containers, background colors, etc., For example, you can highlight part of a line like this. This is plain text, and this is <b>bold</b>

You can use the Awesome font set in the system. This is a set of icons that you can use to make your own beautiful buttons, make icons on cards, screens, etc. A free set of 1001 icons is used (selection by free + selection by solid) https://fontawesome.com/v5.15/icons?d=gallery&p=2&s=solid&m=free In order to use, you need to take the Unicode code from the site, for example f6be, and assign it to a variable with the # prefix - i.e. #f6be, which is then specified in the button or caption title. This can be used in screen elements, dialogs, etc. For example: Button, TextView


8.Other Operation elements (non-UI elements) that can be used:

In the Operation screen structure, the Elements array can contain:

1) a barcode input element – ​​type=barcode, you can set a variable for it, in which the barcode will be saved. The onInput event with listener=barcode (listener always has the value "barcode", and the variable into which the barcode is placed is the variable specified in Variable) is generated when a barcode is entered.

Example:

{
"type": "barcode",
"Variable": "barcode"
}

2) MenuItem - an item of screen menu. The onInput event with listener= listener=variable_name is generated.
 {
"type": "MenuItem",
"Value": "Save",
"Variable": "menu_save"
}

3)photo - input photo camera device. The onInput event with listener= listener=variable_name is generated. It is recommended to add the mm_local flag variable when creating a screen, which indicates that the image will be saved directly to disk, and the variable will contain generated ID (which is used in horizontal gallery)  and also in another variable with the prefix "_path" the absolute path to the file is saved. For example, if Variable="photo", then when taking a photo, 2 variables will appear in the variable stack: photo and photo_path (a path by which you can read the image and also specify it in elements of the Image type as a link using the "~" prefix). Otherwise, the image value will be saved as base64. You can also use the mm_compression and mm_size variables to set compression and size reduction in percent (from 100 (100%) to 0 (0%))

python:

hashMap.put("mm_local","")
hashMap.put("mm_size","50")
hashMap.put("mm_compression","70")


{
"type": "photo",
"Variable": "photo"
}

4)photoGallery - input picture from device photo gallery. The onInput event with listener= listener=variable_name is generated. It is recommended to add the mm_local flag variable when creating a screen, which indicates that the image will be saved directly to disk, and the variable will contain generated ID (which is used in horizontal gallery)  and also in another variable with the prefix "_path" the absolute path to the file is saved. For example, if Variable="photo", then when taking a photo, 2 variables will appear in the variable stack: photo and photo_path (a path by which you can read the image and also specify it in elements of the Image type as a link using the "~" prefix). Otherwise, the image value will be saved as base64. You can also use the mm_compression and mm_size variables to set compression and size reduction in percent (from 100 (100%) to 0 (0%))


python:

hashMap.put("mm_local","")
hashMap.put("mm_size","50")
hashMap.put("mm_compression","70")


{
"type": "photoGallery",
"Variable": "photo"
}

5) fab - floating action button. You can place your own buttons on top of the screen, at the bottom right. You need to define a Variable and Value for the element. In the Value, you can either write the name of one of the predefined icons ("forward", "backward", "run", "cancel", "edit", "picture", "info", "settings", "plus", "save", "search", "send", "done") or use an Awesome icon.

6) HorizontalGallery - The input variable is a JSON array of either file identifiers (in case of the mm_local flag (see above in the photo description)) of the type ["id1","id2"…] or a JSON array of the form [{"uid":"id1","base64":"image 1 data"},{"uid":"id2","base64":"image 2 data"}], that is, an array containing the data itself in base64 form. The array itself is formed when multimedia is added from the camera or gallery, or deleted. That is, for operation it is enough to place a gallery element and "Photo from camera" or "Photo from gallery" and specify any variable. When working with multimedia or deleting, input events with listener=variable name will occur, in which the variable with the array can be obtained in the handler and thus gain access to the files.When the user changes the gallery, the "gallery_change" event listener occurs. The new array of images can be retrieved from the gallery variable.If the screen contains both a gallery and elements like Camera photo or Gallery photo, then the gallery array is placed automatically

{
"type": "HorizontalGallery",
"Variable": "photoGallery",
"Value":"photoGallery"
}


python:

if hashMap.get("listener")=="photo": #camera photo taking event

image_file = str(hashMap.get("photo_path")) # "variable"+"_path" - path to the received photo is placed here
jphotoarr = json.loads(hashMap.get("photoGallery")) #array with gallery, links are placed

elif hashMap.get("listener")=="gallery_change": #user can delete photo from gallery. You can get a new array
if hashMap.containsKey("photoGallery"):
jphotoarr = json.loads(hashMap.get("photoGallery"))

#you can fill and place the array manually
hashMap.put("photoGallery",json.dumps(jphotoarr))

7) ImageSlider - A similar HorizontalGallery, only with a different appearance - in the form of a slider. The work is completely analogous to the HorizontalGallery.



9. Important Notes
All Python code must be base64 encoded

Use hashMap.put("variable", "value") to save data

Use hashMap.get("variable") to read data

Text displays can show variables using @variable_name

This simplified version:

Uses shorter sentences

Avoids complex technical terms

Shows basic examples first

Focuses on practical steps

Omits advanced features



10. Global variables

Variables in hashMap exist as long as the process exists. But if you need to pass a variable between processes or between, for example, the onLaunch handler, you should add the prefix "_" to the variable. For example, hashMap.put("_myVariable","Hello world") will be available as long as the application is running.

11. Saving in key-value mode

The _local object is available in the default handler - this is a DBMS in key-value format that stores data on disk.

It can store the following values: Simple types (string, number, boolean), Dictionary and list (dict and list) without prior conversion, hashMap without conversion. Other types must be converted.

_local has methods:

1)put(key,value) – save value

2)get(key) – get value

3)delete(key) – delete key

4)destroy() – delete entire configuration DB

5)keys() – get all configuration keys as a list

Examples:

python:
#can save primitive types
_local.put("my","hello")
_local.put("number",25.4)
_local.put("setting1",True)

#can save dict and list
my_object = {"name":"Jhon"}
_local.put("j2",my_object )

#can save variable stack
_local.put("map",hashMap)

#get values
toast(_local.get("my"))
#get all keys
keys = _local.keys()
toast("Total keys:"+str(len(keys)))
#object retrieval
j = _local.get("j2")
if not j==None:
toast(str(j["name"]))

12. Saving in noSQL Pelican

Storage in the JSON-oriented DBMS "Pelican" is available.

If one or more Pelican DBMS are used in the configuration, then in the "ClientConfiguration" object you need to add the "PelicanInit" key, which will store a JSON array serialized into a string with one or more settings of the DBMS used. For example

"PelicanInit": "[{\n\"database\":\"test_database\",\n\"singletone\":true,\n\"initialize\":true\n}]"

You need to specify your database name in the database, leave the rest as is.

After that, in any handler, to access the database you need:

from pelican import pelicans
db = pelicans['test'] #get a ready-to-use DB anywhere

Records are located in collections. The correct way to access a collection is

db[collection_name] #wrong call is db.get("collection_name"). This is not work.

For example:

result = db["goods"].all() 

One database can have many collections.

The record contains "_id" - this is the record key by which you can get the record using the get(ID) method. If it is not specified explicitly, it will be generated when adding. When updating a record (upsert=True), the record by _id is updated.

The condition for find() methods is similar to the MongoDB condition syntax (Be careful - Pelican does not have find_one, only find)

The fastest search is either get (by key) or by index. Therefore, if you need to find a product by barcode, for example, it is better to have an index in advance. It is better to place the creation of the index before using it, for example in onLaunch

Examples that show working with Pelican

from pelican import pelicans
db = pelicans['samples_db1']

#adding a document without an ID
id = db["goods"].insert({"name":"Banana"})
print("Added:",id,sep=" ")

#adding a document with an ID
try:
	id = db["goods"].insert({"name":"Banana", "_id":"1"})
except:
	print("Such a document already exists")

#Upsert a document
db["goods"].insert({"name":"Peach", "price":100, "_id":"2"}, upsert=True)
db["goods"].insert({"name":"Peach", "price":99, "_id":"2"}, upsert=True)

#Adding a collection
ids = db["goods"].insert([{"name":"Apple", "price":60}, {"name":"Pear", "price":70}], upsert=True)
print("Added:",ids,sep=" ")

#All documents in the collection
result = db["goods"].all()
print(result)

#Get by "_id" key
result = db["goods"].get("2")
print(result)

#same thing via find
result = db["goods"].find({"_id":"2"})
print(result)

#Get a specific version of a document by id
result = db["goods"].get_version("2",0)
print(result)

#search by condition #1
result = db["goods"].find({"name":"Peach"})
print(result)

#search by condition #2
result = db["goods"].find({"price":{"$lte":70}})
print(result)

#search by condition #3
result = db["goods"].find({"name":{"$regex":"Pea"}})
print(result)

#Update - search, update collection documents
#сondition is similar to find, and the data argument is insert/upsert
db["goods"].update({"name":"Peach"},{"updated":True})
print(db["goods"].find({"name":"Peach"}))

#Delete - search, delete collection documents
#сondition is similar to find, and the data argument is insert/upsert
db["goods"].delete({"name":"Peach"})

#сondition as a list
db["goods"].delete(["1","2"])

#shrink deleted entries (optional)
db['goods'].shrink()

#complete deletion of the entire collection
db["goods"].clear()

"""
Indexes: hash index and text index

"""
#hash indexes
db['goods'].register_hash_index("hash_barcode","barcode", dynamic=False) #stored index on the barcode field
#after adding documents, indexes are automatically updated
db["goods"].insert([{"name":"Apple", "price":60, "barcode":"22000001441" }, {"name":"Pear", "price":70,"barcode":"22000001442"}], upsert=True)
#search by index works accordingly
r = db['goods'].get_by_index(db["hash_barcode"],"22000001442")
print(r)


#full text indexes
#registering a text index
db['goods'].register_text_index("text_regular","name", dynamic=False) #there are stored indexes

db["goods"].insert([{"name":"Apple Golden", "price":60, "barcode":"22000001443" }], upsert=True)
t = db['text_regular'].search_text_index("Appl")
print(t)




13. Configuration Example

An example of a configuration consisting of one process, which consists of one screen. The screen has a barcode element (barcode input from a scanner) and manual barcode input through the input field. You can enter a barcode in the input field (with a title), click on the button and the barcode will be added to the list of cards. The same thing will happen if you scan the barcode with a scanner (barcode element). The table uses a card1 container consisting of one inscription.

{
    "ClientConfiguration": {
        "ConfigurationName": "LLM Sample",
        "ConfigurationDescription": "My Configuration",
        "ConfigurationVersion": "0.0.1",
        "Processes": [
            {
                "type": "Process",
                "ProcessName": "Process sample",
                "Operations": [
                    {
                        "type": "Operation",
                        "Name": "Screen 1",
                        "Elements": [
                            {
                                "type": "barcode",
                                "Variable": "barcode"
                            },
                            {
                                "type": "LinearLayout",
                                "orientation": "vertical",
                                "height": "match_parent",
                                "width": "match_parent",
                                "Elements": [
                                    {
                                        "type": "LinearLayout",
                                        "orientation": "horizontal",
                                        "height": "wrap_content",
                                        "width": "match_parent",
                                        "Elements": [
                                            {
                                                "type": "TextView",
                                                "orientation": "vertical",
                                                "height": "wrap_content",
                                                "width": 0,
                                                "Value": "Штрихкод",
                                                "weight": "1",
                                                "height_value": "wrap_content",
                                                "width_value": 0
                                            },
                                            {
                                                "type": "EditTextText",
                                                "orientation": "vertical",
                                                "height": "wrap_content",
                                                "width": 0,
                                                "Value": "@barcode_field",
                                                "Variable": "barcode_field",
                                                "weight": "2",
                                                "height_value": "wrap_content",
                                                "width_value": 0
                                            },
                                            {
                                                "type": "Button",
                                                "orientation": "vertical",
                                                "height": "wrap_content",
                                                "width": 0,
                                                "Value": "Добавить",
                                                "Variable": "btn_add",
                                                "weight": "1",
                                                "width_value": 0,
                                                "height_value": "wrap_content"
                                            }
                                        ],
                                        "weight": "0",
                                        "width_value": "match_parent",
                                        "height_value": "wrap_content"
                                    },
                                    {
                                        "type": "CardsLayout",
                                        "orientation": "vertical",
                                        "height": "match_parent",
                                        "width": "match_parent",
                                        "Value": "@cards",
                                        "weight": "0",
                                        "width_value": "match_parent",
                                        "height_value": "match_parent"
                                    }
                                ],
                                "height_value": "match_parent",
                                "width_value": "match_parent",
                                "weight": "0"
                            }
                        ],
                        "noScroll": true,
                        "hideBottomBarScreen": true,
                        "Handlers": [
                            {
                                "event": "onStart",
                                "action": "run",
                                "listener": "",
                                "type": "pythonscript",
                                "method": "aW1wb3J0IGpzb24KCmogPSB7ICJjdXN0b21jYXJkcyI6ICAgICAgICAgewogIm9wdGlvbnMiOnsKICAgICAgICAgICAic2VhcmNoX2VuYWJsZWQiOlRydWUsCiAgICAgICAgICAgInNhdmVfcG9zaXRpb24iOlRydWUKICAgICAgICAgfSwKICAgICAgICAgImxheW91dCI6ICJeY2FyZDEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICJjYXJkc2RhdGEiOltdfQp9CgppZiBoYXNoTWFwLmNvbnRhaW5zS2V5KCJkYXRhIik6CiAgICBqWyJjdXN0b21jYXJkcyJdWyJjYXJkc2RhdGEiXSA9IGpzb24ubG9hZHMoaGFzaE1hcC5nZXQoImRhdGEiKSkKCmhhc2hNYXAucHV0KCJjYXJkcyIsanNvbi5kdW1wcyhqLGVuc3VyZV9hc2NpaT1GYWxzZSkpCg==",
                                "postExecute": "",
                                "alias": ""
                            },
                            {
                                "event": "onInput",
                                "action": "run",
                                "listener": "barcode",
                                "type": "pythonscript",
                                "method": "aW1wb3J0IGpzb24KCmlmIGhhc2hNYXAuY29udGFpbnNLZXkoImRhdGEiKToKICAgIGRhdGEgPSBqc29uLmxvYWRzKGhhc2hNYXAuZ2V0KCJkYXRhIikpCmVsc2U6CiAgICBkYXRhID0gW10gICAgCgpkYXRhLmFwcGVuZCh7ImJhcmNvZGUiOmhhc2hNYXAuZ2V0KCJiYXJjb2RlIil9KQoKaGFzaE1hcC5wdXQoImRhdGEiLGpzb24uZHVtcHMoZGF0YSxlbnN1cmVfYXNjaWk9RmFsc2UpKQ==",
                                "postExecute": "",
                                "alias": ""
                            },
                            {
                                "event": "onInput",
                                "action": "run",
                                "listener": "btn_add",
                                "type": "pythonscript",
                                "method": "aW1wb3J0IGpzb24KCmlmIGhhc2hNYXAuY29udGFpbnNLZXkoImRhdGEiKToKICAgIGRhdGEgPSBqc29uLmxvYWRzKGhhc2hNYXAuZ2V0KCJkYXRhIikpCmVsc2U6CiAgICBkYXRhID0gW10gICAgCgpkYXRhLmFwcGVuZCh7ImJhcmNvZGUiOmhhc2hNYXAuZ2V0KCJiYXJjb2RlX2ZpZWxkIil9KQoKaGFzaE1hcC5wdXQoImRhdGEiLGpzb24uZHVtcHMoZGF0YSxlbnN1cmVfYXNjaWk9RmFsc2UpKQoKdG9hc3QoImJhcmNvZGUgYWRkZWQiKQ==",
                                "postExecute": "",
                                "alias": ""
                            }
                        ]
                    }
                ]
            }
        ],
        "ConfigurationSettings": {
            "uid": "6fa9d9cb27ce4ace8d82dbd898011c64"
          },
        "Layouts": [
            {
                "type": "LinearLayout",
                "orientation": "vertical",
                "height": "match_parent",
                "width": "match_parent",
                "Variable": "card1",
                "Elements": [
                    {
                        "type": "TextView",
                        "orientation": "vertical",
                        "height": "match_parent",
                        "width": "match_parent",
                        "Value": "@barcode",
                        "TextSize": "20",
                        "weight": "0",
                        "width_value": "match_parent",
                        "height_value": "match_parent"
                    }
                ]
            }
        ],
        "ConfigurationFileName": "llm.ui",
      "uid": "9b6ec3a100bf47a6918c999712e3f208"
    }
}

14. Static resources (media files)

Additional files can be added to the configuration, which can be used for various purposes later. This is added to the "Mediafile" array of the "ClientConfiguration" object.

Example
"Mediafile": [
{
"MediafileKey": "icon1",
"MediafileExt": "jpg",
"MediafileData": "here_base64encoded_file_contents"}
]

If it is a picture, you can access it by key with the prefix "^"

Continuation of the previous example

{
"type": "Picture",
"Value": "^icon1"
}

You can also access a static resource by key:

You can access any static resource by key, get its absolute name and then do whatever you need with it:

from ru.travelfood.simple_ui import SimpleUtilites as suClass
filename = suClass.get_stored_file("key")

14. Common events

You can add events that occur outside the screens. To do this, you can add event handlers to the "CommonHandlers" array of the object "ClientConfiguration"

1) "event": "onLaunch" - the event occurs when the configuration is loaded. Can be used to initialize variables or databases, for example.

"CommonHandlers": [
            {
                "event": "onLaunch",
                "action": "run",
                "listener": "",
                "type": "pythonscript",
                "method": "aGFzaE1hcC5wdXQoIl9teUdsb2JhbCIsImhlbGxvIik=",
                "postExecute": "",
                "alias": ""
            }
        ]



